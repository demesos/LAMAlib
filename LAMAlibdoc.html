<html>
<body>
<h1>LAMAlib - Lightweight Assembler MAcro library for cc65</h1>
Version: 0.211<br>
Date: 2022-09-15<br>
Author: Wil Elmenreich (wilfried at gmx dot at)<br>
License: The Unlicense (public domain)<br>
<br>
<h2>Installation and Usage</h2>
To use LAMAlib you need to have cc65 installed. Get it at https://cc65.github.io<br>
<br>
<h3>Possibility 1: Install in cc65</h3>
There is a script <tt>install_lamalib.bat</tt> included which does the following:<br>
<ul><li>Copies all LAMAlib*.inc files into directory <tt>asminc</tt> of your cc65 installation.<br>
<li>Copies the file LAMAlib.lib into directory <tt>lib</tt> of your cc65 installation.<br>
</ul>
</ul>You don't need to keep the original folder of LAMAlib, but you probably want to keep a copy of the documentation, LAMAlibdoc.html<br>
<br>
<br>
In your programs,<br>
<ul><li>add a line <tt>.include "LAMAlib.inc"</tt> at the top of your assembler file<br>
<li>assemble with command <tt>cl65 yourprog.s -lib LAMAlib.lib -C c64-asm.cfg -u __EXEHDR__ -o yourprog.prg</tt>
<li>alternatively, use the provided shellscripts ass.bat / ass.sh: <tt>ass yourprog.s</tt>
</ul>
<br>
Usage: <tt>ass [-20|-128] asmfile [startaddr]</tt>
<br>
Calls the cl65 assembler and linker and creates an executable <tt>.PRG</tt> for the C64, unless <tt>-20</tt> or <tt>-128</tt> is specified, then the program will be assembled for the VIC20 or C128, respectively.<br>
<br>
<h3>Possibility 2: Keep LAMAlib separately</h3>
Keep a copy of the LAMAlib folder in a sister directory of your project. You need then to link to the library via its relative or absolute path.<br>
<br>
In your programs,<br>
<ul><li>add a line <tt>.include "../LAMAlib/LAMAlib.inc"</tt> at the top of your assembler file (the forward slash works on Linux as well as on Linux systems)<br>
<li>assemble with command <tt>cl65 yourprog.s -lib ../LAMAlib/LAMAlib.lib -C c64-asm.cfg -u __EXEHDR__ -o yourprog.prg</tt>
<li>when you publish source code of your project you can add LAMAlib to the package. The license of LAMAlib has been chosen to be maximum permissive, so whatever project you have, there should be no problems adding the code.<br>
</ul>
<br>
<h2>Points to remember</h2>
Please note that the zero flag for 16 operations is not properly set for most macros except CMP. For example after a 16 bit calculation, a CMPAX #00 is necessary to test for zero in AX.<br>
Instead of many zero page variables, the library functions uses self-contained self-modifying codeblocks whenever possible, but some of the more complex functions like division and multiplication use zero page addresses, they are reserved in the segment "ZEROPAGE".<br>
<br>
<br>
<h1>Command documentation</h1>
<br>
<h2>Switches</h2>
<br>
<b>USE_BASIC_ROM</b> .set [0|1]<br>
This switch tells LAMAlib if it should use calls into BASIC ROM or not. If USE_BASIC_ROM ist set to 0, LAMAlib uses its own implementations for printstr and print number.<br>
The LAMAlib implementations are also faster, so USE_BASIC_ROM can also be set to 0 if you would like to increase performance.<br>
USE_BASIC_ROM does not actually change the ROM configuration.<br>
The switch can be changed multiple times to create program parts using the ROM and parts that do not.<br>
<h2>16-bit Emulation Macros</h2>
<br>
<b>ldax</b> <i>addr</i><br>
<b>ldax</b> <i>#arg</i><br>
Loads a 16-bit value into A/X, either from an address or as immediate value<br>
Note that the zero flag is not indicating 0 but indicating a value <256<br>
Supports zero page addressing mode<br>
Registers modified: A,X<br>
<br>
<b>stax</b> <i>addr</i><br>
Stores the value in registers A and X to addr and addr+1<br>
Supports zero page addressing mode<br>
Registers modified: none<br>
<br>
<b>adcax</b> <i>addr</i><br>
<b>adcax</b> <i>#arg</i><br>
Adds a 16 bit value with carry at an addr or as immediate value to 16 bit value in registers A/X<br>
Supports zero page addressing mode<br>
Result is returned in A/X<br>
Registers modified: A,X<br>
<br>
<b>addax</b> <i>addr</i><br>
<b>adcax</b> <i>#arg</i><br>
Adds a 16 bit value without carry at an addr or as immediate value to 16 bit value in registers A/X<br>
Supports zero page addressing mode<br>
Result is returned in A/X<br>
Registers modified: A,X<br>
<br>
<b>sbcax</b> <i>addr</i><br>
<b>sbcax</b> <i>#arg</i><br>
Subtracts the 16 bit value with carry at an addr or as immediate value from  16 bit value in registers A/X<br>
Supports zero page addressing mode<br>
Result is returned in A/X<br>
Registers modified: A,X<br>
<br>
<b>subax</b> <i>addr</i><br>
<b>sbcax</b> <i>#arg</i><br>
Subtracts the 16 bit value with carry at an addr or as immediate value from  16 bit value in registers A/X<br>
Supports zero page addressing mode<br>
Result is returned in A/X<br>
Registers modified: A,X<br>
<br>
<b>rsc</b> <i>arg</i><br>
<b>rsc</b> <i>#arg</i><br>
Reverse subtraction with carry, calculate the value of arg - A - C<br>
if the carry is clear before the command, this behaves like rsc<br>
If there is an underflow (arg is larger than A), the carry bit will be set, otherwise carry is clear<br>
<br>
<b>rsb</b> <i>arg</i><br>
<b>rsb</b> <i>#arg</i><br>
Reverse subtraction, calculate the value of arg - A<br>
The result is not influenced by the carry<br>
If there is an underflow (arg is larger than A), the carry bit will be set, otherwise carry is clear<br>
<br>
<b>rscax</b> <i>arg</i><br>
<b>rscax</b> <i>#arg</i><br>
16 bit reverse subtraction, calculate the value of arg - AX - C<br>
if the carry is clear before the command, this behaves like rsbax<br>
If there is an underflow (arg is larger than AX), the carry bit will be set, otherwise carry is clear<br>
<br>
<b>rsbax</b> <i>arg</i><br>
<b>rsbax</b> <i>#arg</i><br>
16 bit reverse subtraction, calculate the value of arg - AX<br>
The result is not influenced by the carry<br>
If there is an underflow (arg is larger than AX), the carry bit will be set, otherwise carry is clear<br>
<br>
<b>cmpax</b> <i>addr</i><br>
<b>cmpax</b> <i>#arg</i><br>
Compares the value in A/X with the 16 bit value in addr or the immediate value<br>
Supports zero page addressing mode<br>
Result is returned in A/X<br>
Registers modified: A,X<br>
<br>
<b>orax</b> <i>addr</i><br>
<b>orax</b> <i>#arg</i><br>
Calculates the bitwise OR operation between A/X and a 16 bit value at an addr or as immediate value<br>
Supports zero page addressing mode<br>
Result is returned in A/X<br>
Registers modified: A,X<br>
<br>
<b>andax</b> <i>addr</i><br>
<b>andax</b> <i>#arg</i><br>
Calculates the bitwise AND operation between A/X and a 16 bit value at an addr or as immediate value<br>
Supports zero page addressing mode<br>
Result is returned in A/X<br>
Registers modified: A,X<br>
<br>
<b>eorax</b> <i>addr</i><br>
<b>eorax</b> <i>#arg</i><br>
Calculates the bitwise exclusive-or operation between A/X and a 16 bit value at addr or as immediate value<br>
Supports zero page addressing mode<br>
Result is returned in A/X<br>
Registers modified: A,X<br>
<br>
<b>aslax</b><br>
Performs an arithmetic shift left of A/X (essentially a multiplication with 2, MSB goes into carry)<br>
Result is returned in A/X<br>
Registers modified: A,X<br>
<br>
<b>asl16</b> <i>addr</i><br>
Performs an arithmetic shift left of a 16 bit number at addr<br>
Result at addr, addr+1<br>
Registers modified: none<br>
<br>
<b>lsrax</b><br>
Performs a logic shift right of A/X (essentially a division by 2, LSB goes into carry)<br>
Result is returned in A/X<br>
Registers modified: A,X<br>
<br>
<b>lsr16</b> <i>addr</i><br>
Performs a logic shift right of a 16 bit number at addr<br>
Result at addr, addr+1<br>
Registers modified: none<br>
<br>
<b>rolax</b><br>
Performs a rotate left of A/X (essentially a multiplication with 2, carry goes into LSB, MSB goes into carry)<br>
Result is returned in A/X<br>
Registers modified: A,X<br>
<br>
<b>rol16</b> <i>addr</i><br>
Performs a rotate left of a 16 bit number at addr<br>
Result at addr, addr+1<br>
Registers modified: none<br>
<br>
<b>rorax</b><br>
Performs a rotate right of A/X (essentially a division by 2, carry goes into MSB, LSB goes into carry)<br>
Result is returned in A/X<br>
Registers modified: A,X<br>
<br>
<b>ror16</b> <i>addr</i><br>
Performs a rotate right of a 16 bit number at addr<br>
Result at addr, addr+1<br>
Registers modified: none<br>
<br>
<b>negax</b><br>
Negates the value in A/X<br>
Result is returned in A/X<br>
Registers modified: A,X<br>
<br>
<b>absax</b><br>
Makes the signed 16 bit value in A/X an absolute value<br>
Result is returned in A/X<br>
Registers modified: A,X<br>
<br>
<b>incax</b><br>
Increments 16 bit value in registers A/X<br>
Registers modified: A,X<br>
<br>
<b>inc16</b> <i>addr</i><br>
Increments the value stored at addr (lo-byte) and addr+1 (hi-byte) as a 16 bit value<br>
Registers modified: none<br>
<br>
<b>decax</b><br>
Decrements 16 bit value in registers A/X<br>
Registers modified: A,X<br>
<br>
<b>dec16</b> <i>addr</i><br>
Decrements the value stored at addr (lo-byte) and addr+1 (hi-byte) as a 16 bit value<br>
Registers modified: A<br>
<br>
<b>incx</b> <i>n</i><br>
Increments the X register by a value of n<br>
Registers modified: X<br>
Flags affected: N,Z,C<br>
<br>
<b>decx</b> <i>n</i><br>
Decrements the X register by a value of n<br>
Registers modified: X<br>
Flags affected: N,Z,C<br>
<br>
<b>incy</b> <i>n</i><br>
Increments the Y register by a value of n<br>
Registers modified: Y<br>
Flags affected: N,Z,C<br>
<br>
<b>decy</b> <i>n</i><br>
Decrements the Y register by a value of n<br>
Registers modified: Y<br>
Flags affected: N,Z,C<br>
<br>
<b>pushax</b><br>
Pushes AX to the stack and preserves AX<br>
<br>
<b>pullax</b><br>
Pulls AX from the stack<br>
<br>
<b>poke</b> <i>arg1,arg2</i><br>
Copies arg2 into the address of arg1<br>
arg1 can be a constant or AX<br>
arg2 can be a constant or A, X or Y<br>
<br>
<b>pokew</b> <i>arg1,arg2</i><br>
poke word: copies 16 bit value arg2 into the address of arg1 and arg1+1<br>
arg1 will be filled with low byte of arg2<br>
arg2 will be filled with high byte of arg2<br>
arg1, arg2 can be both constants or one can be AX and the other a constant<br>
Regs changed: A, Y (in case AX is used as address)<br>
<br>
<b>jsr_ind</b> <i>addr</i><br>
Executes a subroutine by a vector stored in addr and returns to the command after jsr_ind upon completion with an rts<br>
arg1 will be a 16 bit address containing the vector to jump to<br>
Regs changed: none<br>
<h2>Hires Graphics Functions - CURRENTLY UNDER DEVELOPMENT</h2>
<br>
<b>blank_screen</b><br>
Waits until rasterbar is below screen area, then blanks the screen and shows only the border color<br>
<br>
<b>unblank_screen</b><br>
Shows the screen again after it was blanked, effective with next frame<br>
<br>
<b>bitmap_on</b><br>
Turn bitmap mode on and initialize tables in case the project uses plotting commands (plot, line, circle, ...)<br>
<br>
<b>bitmap_off</b><br>
Turn bitmap mode off<br>
<br>
<b>gfx_clrscr</b> <i>bgcolor,fgcolor</i><br>
Clear graphics screen and set background and foreground colors<br>
<br>
<b>gfx_init</b> <i>[gfxtablebase]</i><br>
Initializes the look up tables used by the gfx_plot function<br>
The optional argument defines where the look up tables needed by gfx_pset and gfx_pclr are placed ($2c9 bytes). This address should be page-aligned ($xx00). Without the argument, the address $9000 is used as a default.<br>
This macro needs to be called once before using gfx_plot or any function that uses gfx_plot (e.g. gfx_line)<br>
Uses all registers and overwrites memory area gfxtables<br>
<br>
<b>gfx_pset</b><br>
Sets pixel at position x=X register (Carry indicating values > 255), y=Y register<br>
<br>
<b>gfx_pclr</b><br>
Clears pixel at position x=X register (Carry indicating values > 255), y=Y register<br>
<br>
<b>gfx_pget</b><br>
Reads pixel at position x=X register (Carry indicating values > 255), y=Y register<br>
Return value (0 or 1) in A<br>
<br>
<b>set_VIC_charset</b> <i>addr</i><br>
Sets VIC register $D018 to have the charset at the given address<br>
addr must be a constant that is a multiple of $800<br>
This macro does not adjust the VIC bank, see set_VIC_bank<br>
<br>
<b>set_VIC_screen</b> <i>addr</i><br>
Sets VIC register $D018 to have the screen RAM at the given address<br>
addr must be a constant that is a multiple of $400<br>
This macro does not adjust the VIC bank, see set_VIC_bank<br>
<br>
<b>set_VIC_addr</b> <i>screen_addr,charset_addr</i><br>
Sets VIC register $D018 to have the screen RAM and the charset at the given addresses<br>
screen_addr must be a constant that is a multiple of $400, charset_addr a multiple of $800<br>
This macro does not adjust the VIC bank, see set_VIC_bank<br>
<br>
<b>set_VIC_bank</b> <i>addr</i><br>
Sets CIA register $DD00 to have the VIC RAM bank at the given address<br>
addr must be a constant that is a multiple of $4000<br>
<h2>Structured Programming</h2>
These commands allow you to use constructs like <i>if .. else .. endif</i>, <i>do...loop</i>, <i>for...next</i>, and <i>switch...case</i> in assembly language! The structures can even be nested. The implementation of these structures is basically as efficient as a a handcoded composure of branches, jumps as labels, while it is much easier to write and read.<br>
All macros can be nested.<br>
<br>
<b>store</b> <i>reg</i><br>
Generates self-modifying code for store/restore of a register<br>
Registers can be A,X,Y, or AX (that is A and X)<br>
An example application for <i>store</i>/<i>restore</i> is for saving a register to be able use it in between. An alternative to <i>store</i>/<i>restore</i> are stack push/pull, which is more compact, but 1 cycle slower.<br>
Each store must match with exactly one <i>restore</i> macro using the same register, restore has to be placed later in your code<br>
Registers modified: none<br>
<br>
<b>restore</b> <i>reg</i><br>
Generates the code for restoreing a stored register<br>
Registers can be A,X,Y, or AX (that is A and X)<br>
Each restore must match with exactly one preceding <i>store</i> macro using the same register<br>
Registers modified: the restoreed register<br>
<br>
<b>if</b> <i>cond</i><br>
...<br>
[<b>else</b>]<br>
...<br>
<b>endif</b><br>
This is a structure for conditional execution<br>
<i>cond</i> can be <i>eq</i>, <i>ne</i>, <i>mi</i>, <i>pl</i>, <i>cc</i>, <i>cs</i>, <i>vc</i>, <i>vs</i>, <i>lt</i>, <i>ge</i><br>
This corresponds to assembler commands BEQ, BNE, BMI, BPL, BCC, BCS, BVC, BVS<br>
Therefore the amount of code between if and else must not exceed the range of a branch instruction (127 byte for a forward branch)<br>
<i>lt</i> (less than) is equal to <i>cc</i> (BCC), <i>ge</i> (greater or equal) is equal to <i>cs</i> (BCS)<br>
using else is optional<br>
Registers modified: none<br>
<br>
<b>for</b> <i></i><b>X|Y|A|AX</b><i>|addr,start,</i><b>to|downto</b><i>,end,step</i><br>
...<br>
<b>next</b><br>
The for loop iterates from the start value to the end value, inclusive. This is similar to the behavior of FOR in BASIC<br>
Counting variable can be an 8-bit register (A,X,Y), a 16 bit register (AX) or a 16 bit memory address/label (parentheses are optional)<br>
<i>start</i> can be a constant or a memory address pointing to the value<br>
<i>end</i> can be a constant or a memory address pointing to the value. The loop is continued including an iteration reaching the <i>end</i> value<br>
<i>start</i> can be a constant or a memory address pointing to the value<br>
<b>to</b> indicates a loop that counts up, <b>downto</b> indicates a loop that counts down<br>
<i>end</i> can be a constant or a memory address pointing to the value<br>
<b>step</b> is optional and defines the increment/decrement (default=1). This value is alway positive, counting down is indicated with <b>downto</b><br>
<br>
When the loop variable is an 8 bit register, <i>start</i>, <i>end</i>, and <i>step</i> are a single byte (or a memory reference to a single byte)<br>
When the loop variable is a 16 bit register (AX) or a 16 bit memory address, <i>start</i>, <i>end</i>, and <i>step</i> are a 16 bit value (or a memory reference to a 16 bit value)<br>
Memory references can also go to zero page. In this case the zero page addressing mode is used which speeds up the code.<br>
When <i>step</i> is larger than 1 or no constant, loops that count down can are limited to a 7 bit (for single register loops) or a 15 bit range<br>
It is possible to nest multiple for loops but each <b>for</b> must be followed by exactly one corresponding <i>next</i> later in the code.<br>
<br>
Within a for loop, the macros <i>break</i> and <i>continue</i> can be used to exit the loop or go to next iteration.<br>
<br>
Registers modified: the loop register and A for indirectly given step values<br>
<br>
Code example that outputs '9876543210':<br>
<code><br>
for A,$39,downto,$30<br>
&nbsp;  jsr $ffd2<br>
next<br>
</code><br>
<br>
<b>do</b><br>
...<br>
[<b>until</b>|<b>while</b> <i>cond</i>]<br>
...<br>
<b>loop</b> [<b>until</b>|<b>while</b> <i>cond</i>]<br>
Defines a loop that is exit based on a while or until condition<br>
<i>cond</i> can be <i>eq</i>, <i>ne</i>, <i>mi</i>, <i>pl</i>, <i>cc</i>, <i>cs</i>, <i>vc</i>, <i>vs</i>, <i>lt</i>, <i>ge</i><br>
This corresponds to assembler commands BEQ, BNE, BMI, BPL, BCC, BCS, BVC, BVS<br>
<i>lt</i> (less than) is equal to <i>cc</i> (BCC), <i>ge</i> (greater or equal) is equal to <i>cs</i> (BCS)<br>
<b>until</b> and <b>while</b> can be used on a seperate line or after <b>loop</b><br>
There can be any number of <b>until</b> or <b>while</b> conditions, also none, which defines an endless loop<br>
Within a do...loop, the macros <i>break</i> and <i>continue</i> can be used to exit the loop or go to next iteration.<br>
Any line with a until, while, loop until, or while until will be typically preceded with code that sets the respective processor flags, in many cases this<br>
will be a compare instruction. For example the C code while loop:<br>
<code><br>
while(i>1) {<br>
&nbsp;  do_something()<br>
&nbsp;  i--;<br>
}<br>
</code><br>
would translate into<br>
<code><br>
do<br>
&nbsp;  cpy #2 ;1+1<br>
&nbsp;  while ge<br>
&nbsp;  jsr do_something<br>
&nbsp;  dey<br>
loop<br>
</code><br>
<br>
Registers modified: A, if the loop variable is X or Y also the respective X or Y register<br>
<br>
Code example that waits for joystick 2 button to be pressed:<br>
<code><br>
lda #$10<br>
do<br>
&nbsp;  and $dc00<br>
loop until eq<br>
</code><br>
<br>
<b>switch</b> <i></i><b>[A|X|Y|AX]</b><i></i><br>
<b>[case|case_eq|case_lt|case_ge]</b> <i>num1</i><br>
...<br>
<b>[break]</b><br>
<b>[case|case_eq|case_lt|case_ge]</b> <i>num2</i><br>
...<br>
<b>[break]</b><br>
<b>[case|case_eq|case_lt|case_ge]</b> <i>num3</i><br>
...<br>
...<br>
<b>[break]</b><br>
<b>[default]</b><br>
<b>endswitch</b><br>
Defines a selection mechanism to allow the value of a register to change the control flow<br>
<b>case</b> and <b>case_eq</b> are the same function, they trigger if the register value and the comparison value are identical<br>
<b>case_lt</b> ("less than") triggers if the register value is smaller than the comparison value<br>
<b>case_ge</b> ("greater or equal") triggers if the register value is greater or equal than the comparison value<br>
<b>break</b> jumps out of the structure. Other than with the switch structure in C, fallthroughs before another case do not work because there is code generated for the comparison and branch function before each case part.<br>
Only a fallthrough into the default part works correctly.<br>
<b>default</b> performs no comparison but triggers always, there is no need for a break command at the end of default<br>
Registers modified: none<br>
<br>
Example:<br>
	<pre><br>
	switch A<br>
	case 1:<br>
	   print "one"<br>
	   break<br>
	case 2:<br>
	   print "two"<br>
	   break<br>
	case 3:<br>
	   print "one"<br>
	   break<br>
	default:<br>
	   print "?"<br>
	endswitch<br>
	</pre><br>
<h2>Useful Routines</h2>
<br>
<b>_ld_reg</b> <i>reg,arg</i><br>
<b>_st_reg</b> <i>reg,arg</i><br>
<b>_cp_reg</b> <i>reg,arg</i><br>
macros to select register for a load, store, and compare operation.<br>
For example, _ld_reg A,#12 translates into lda #12 while _st_reg $1234,Y translates into sty $1234<br>
if reg is blank, A is used as a default<br>
Those funcations are mostly used in other macros.<br>
<br>
<b>check_C128</b><br>
Detects if we are on a C128 in C64 mode<br>
returns with carry set for C128<br>
<br>
<b>clrscr</b><br>
Clears the screen<br>
KERNAL ROM needs to be enabled when using this function<br>
Registers modified: A,Y,X<br>
<br>
<b>checksum_eor</b> <i>startaddr,endaddr</i><br>
Returns an 8-bit checksum calculated by EOR-conjunction over all bytes<br>
<br>
<b>clear_window</b><br>
Clears the window that was defined by the window parametes above. When chrout2window is enabled, the same effect can be achieved by lda #147, jsr $FFD2<br>
<br>
<b>decimal_flag_to_N</b><br>
Copies the decimal flag into the negative flag to detect if decimal mode is on<br>
Macro always returns with a cleared Carry<br>
Registers modified: A<br>
<br>
<b>delay_cycles</b> <i>arg</i><br>
Delays for arg cycles using a busy waiting approach. This does not account for interrupts or stolen cycles by VIC badlines.<br>
arg must be a constant >=2<br>
generated code does not need to be aligned, but requires around 0.3 bytes/cycle in memory<br>
Registers modified: none (but flags may be messed up)<br>
<br>
<b>delay_ms</b> <i>arg</i><br>
Delays for arg milliseconds using a busy waiting loop. This does not account for interrupts or stolen cycles by VIC badlines.<br>
When AX is given as argument it waits as many ms as the 16 bit value in A/X<br>
When a number (1-65536) is given as argument it waits this long<br>
Registers modified: A,X<br>
<br>
<b>disable_chrout2window</b><br>
Restores the original Kernal vector and disables the chrout2window mode<br>
<br>
<b>disable_NMI</b><br>
Executes a short routine to disable the NMI<br>
the trick is to cause an NMI but don't ackowledge it<br>
Uses CIA2 Timer A, but the timer can be used afterwards (without IRQ function)<br>
Registers modified: A<br>
Returns the disk status error message number in A<br>
This code only reads the number without further text<br>
Error codes (listed in decimal) are:<br>
0   OK, no error exists<br>
1   Files scratched response. Not an error condition<br>
20  Block header not found on disk<br>
21  Sync character not found<br>
22  Data block not present<br>
23  Checksum error in data<br>
24  Byte decoding error<br>
25  Write-verify error<br>
26  Attempt to write with write protect on<br>
27  Checksum error in header<br>
28  Data extends into next block<br>
29  Disk id mismatch<br>
30  General syntax error<br>
31  Invalid command<br>
32  Long line<br>
33  Invalid filename<br>
34  No file given<br>
39  Command file not found<br>
50  Record not present<br>
51  Overflow in record<br>
52  File too large<br>
60  File open for write<br>
61  File not open<br>
62  File not found<br>
63  File exists<br>
64  File type mismatch<br>
65  No block<br>
66  Illegal track or sector<br>
67  Illegal system track or sector<br>
70  No channels available<br>
71  Directory error<br>
72  Disk full or directory full<br>
73  Power up message, or write attempt with DOS Mismatch<br>
74  Drive not ready<br>
<br>
<b>div16</b> <i>arg</i><br>
Multiplies the unsigned 16 bit value in A/X with an imediate value or the 16 bit value stored at addr (lo-byte) and addr+1 (hi-byte)<br>
Implemented as a subroutinge, link with -lib lamalib.lib<br>
This function is not reentrant, don't use in interrupt and main program simultaneously<br>
Result is returned in A/X<br>
Registers modified: all<br>
<br>
<b>draw_frame</b><br>
Draws a frame around the window defined by the window parameters<br>
Note that the frame will go around the window, so it is larger than the defined window<br>
Window parameters:<br>
<tt>.import _window_x1,_window_y1,_window_x2,_window_y2</tt><br>
Further configuration parameters (default is a white frame using PETSCII characters):<br>
<tt> .import _frame_upper_left<br>
.import _frame_upper_right<br>
.import _frame_lower_left<br>
.import _frame_lower_right<br>
.import _frame_vertical<br>
.import _frame_horizontal<br>
.import _frame_color</tt><br>
For example to change the color of the frame to green, write<br>
<tt>  .import _frame_color<br>
poke _frame_color,5</tt><br>
<br>
<b>enable_chrout2window</b><br>
Switches the Kernal chrout vector to a routine that prints within a window<br>
The page of the textscreen (stored in $288 / 648) is used to determine the output screen, but if you change the screen page, <b>enable_chrout2window</b> needs to be called again.<br>
Limitations: no backspace, no insert<br>
Note that control character keypresses in direct mode are not handled via $FFD2, therefore pressing for example CLR/HOME will leave the window in direct mode.<br>
Window parameters:<br>
<tt>.import _window_x1,_window_y1,_window_x2,_window_y2</tt><br>
For example to set a window starting on column 5, write<br>
<tt>  .import _window_x1<br>
poke _window_x1,5</tt><br>
<br>
<b>getkey</b><br>
clears the key buffer, waits for a keypress and returns the ASCII value of the pressed key in A<br>
relies on the interrupt routine regularily scanning the keyboard<br>
<br>
<b>identify_SID</b> <i>[baseaddress]</i><br>
Detects the SID soundchip model<br>
SID detection routine from codebase64 by SounDemon and a tip from Dag Lem<br>
If no base address is given, the standard base address $d400 is used<br>
Overwrites register A<br>
Result is returned in carry<br>
Carry flag is set for 6581, and clear for 8580<br>
<br>
<b>is_alpha</b><br>
is_alpha tests if value in Accu is between the values 'a' and 'z' (in lowercase mode).<br>
Return value: Carry set if value is in range, carry cleared otherwise<br>
Registers modified: none<br>
<br>
<b>is_not_alpha</b><br>
is_alpha tests if value in Accu is <b>not</b> between the values 'a' and 'z' (in lowercase mode).<br>
Return value: Carry set if value is outside range, carry cleared otherwise<br>
Registers modified: none<br>
<br>
<b>is_digit</b><br>
is_digit tests if value in Accu is between the values '0' and '9'.<br>
Return value: Carry set if value is a digit, carry cleared otherwise<br>
Registers modified: none<br>
<br>
<b>is_not_digit</b><br>
is_not_digit tests if value in Accu is <b>not</b> between the values '0' and '9'.<br>
Return value: Carry clear if value is a digit, carry set otherwise<br>
Registers modified: none<br>
<br>
<b>is_in_range</b> <i>lower,higher</i><br>
Tests if value in Accu is between the values <i>lower</i> and <i>higher</i><br>
Return value: Carry set if value is in range, carry cleared otherwise<br>
Registers modified: none<br>
<br>
<b>is_not_in_range</b> <i>lower,higher</i><br>
Tests if value in Accu is outside the values <i>lower</i> and <i>higher</i><br>
Return value: Carry set if value is outside range, carry cleared otherwise<br>
Registers modified: none<br>
<br>
<b>is_in_range_trash_A</b> <i>lower,higher</i><br>
Tests if value in Accu is between the values <i>lower</i> and <i>higher</i><br>
If the value was inside, the Carry is set, otherwise the Carry is cleared<br>
Registers modified: A<br>
<br>
<b>load_prg</b> <i>filename[,devicenr[,loadaddr]]</i><br>
Wrapper around ROM load function, prg means that the file is assumed to have a two-byte load address at its start<br>
if device number is 0 or not stated, the last used device numner stored in address $BA is used. In case $BA contains 0, 8 is used as default<br>
if loadaddr is omitted, the load address is defined by the first two bytes of the file<br>
Return value in carry, if carry is set, an error has happened and error code is returned in A:<br>
A = $05 (DEVICE NOT PRESENT)<br>
A = $04 (FILE NOT FOUND)<br>
A = $1D (LOAD ERROR)<br>
A = $00 (BREAK, RUN/STOP has been pressed during loading)<br>
Registers modified: A,X,Y<br>
<br>
<b>lowercase_mode</b><br>
Switches charset to upper/lowercase (text) mode setting and locks the CBM+Shift switch<br>
To switch back, use the macro PETSCII_mode<br>
Registers modified: A<br>
<br>
<b>mul16</b> <i>addr</i><br>
compactmul16 addr<br>
Multiplies the unsigned 16 bit value in A/X with the 16 bit value stored at addr (lo-byte) and addr+1 (hi-byte)<br>
Implemented as a subroutinge, link with -lib lamalib.lib<br>
mul16 adds a routine of 51 byte to your program the first time you use it<br>
compactmul16 adds a routine of 32 byte to your program the first time you use it<br>
mul16 is about 20% faster than compactmul, we recommend using mul16 in most cases<br>
This function is not reentrant, don't use in interrupt and main program simultaneously<br>
Result is returned in A/X<br>
Registers modified: A,X,Y<br>
<br>
<b>neg</b><br>
Negate A<br>
Registers modified: A<br>
<br>
<b>newline</b><br>
Prints a newline character<br>
KERNAL ROM needs to be enabled when using this function<br>
Registers modified: A<br>
<br>
<b>PETSCII_mode</b><br>
Switches charset to uppercase plus graphical characters (graphics mode) setting and locks the CBM+Shift switch<br>
To switch to upper/lowercase (text) mode, use the macro lowercase_mode<br>
Registers modified: A<br>
<br>
<b>primm</b> <i>str</i><br>
Prints the given string, string is inlined in program code<br>
uses ROM functions, BASIC and KERNAL ROM need to be enabled when using this macro<br>
Registers modified: A,Y,X<br>
<br>
<b>print</b> <i>arg1</i> <i>[arg2</i> <i>...]</i><br>
Prints the arguments as strings or numbers, without a carriage return<br>
An argument in parenthesis will print the 16bit value stored at this address<br>
uses ROM functions, BASIC and KERNAL ROM need to be enabled when using this macro<br>
Use .FEATURE STRING_ESCAPES to enable escapes codes like "\x05" (white) or "\0x0a" (carriage return)<br>
Registers modified: none<br>
<br>
<b>println</b> <i>arg1</i> <i>[arg2</i> <i>...]</i><br>
Prints the arguments as strings or numbers, followed by a carriage return<br>
An argument in parenthesis will print the 16bit value stored at this address<br>
uses ROM functions, BASIC and KERNAL ROM need to be enabled when using this macro<br>
Use .FEATURE STRING_ESCAPES to enable escapes codes like "\x05" (white) or "\0x0a" (carriage return)<br>
Registers modified: none<br>
<br>
<b>printax</b><br>
Prints the number in A/X as a 16 bit unsigned decimal number<br>
BASIC and KERNAL ROM need to be enabled when using this function<br>
Registers modified: A,Y,X<br>
<br>
<b>printa</b><br>
Prints the number in A as a 8 bit unsigned decimal number<br>
BASIC and KERNAL ROM need to be enabled when using this function<br>
Registers modified: A,X<br>
<br>
<b>printax_signed</b><br>
Prints the number in A/X as a 16 bit signed decimal number<br>
BASIC and KERNAL ROM need to be enabled when using this function<br>
Registers modified: A,Y,X<br>
<br>
<b>printstr</b> <i>addr</i><br>
Prints the null-terminated string at addr using the STROUT function<br>
BASIC and KERNAL ROM need to be enabled when using this function<br>
Registers modified: A,Y,X<br>
<br>
<b>rand8</b> <i>[maxvalue-1]</i><br>
Generate a random number between 0 and 255 which is returned in A.<br>
The argument is optional and can be a number or the Y register<br>
If an argument is given, the value is caclulated between 0 and given number-1<br>
Good and fast random generator for 8bit values based on the X ABC pseudo-random number generator from EternityForest, slight modification by Wil.<br>
Registers modified: A,Y (Y is only used when an argument is used)<br>
<br>
<b>rand16</b> <i>[maxvalue-1]</i><br>
Get a random number in AX betwenn 0 and 0xFFFF<br>
The argument is optional and can be a number or AX<br>
If an argument is given, the value is caclulated between 0 and given number-1<br>
This function uses the same routine as rand8, therefore calling rand16 will change the state of rand8 as well<br>
Registers modified: A,X,Y (Y is only used when an argument is used)<br>
<br>
<b><b>rand_setseed</b></b> <i>AX</i> <i>|</i> <i>[[<i>arg1</i>|A|X|Y],</i> <i><i>arg2</i>|A|X|Y]</i><br>
Seed is two 8 bit values. Arguments can be numbers or registers. Specifying seed is optional. When no argument is given, the default value for this seed byte is used.<br>
When setting with AX, there is a check to avoid the seed 0 which would cause the PRNG to lock up. The seed affects both, rand8 and rand16 functions.<br>
Registers modified: normally none, except for the case where lo(AX)==0, then A is set to $FF<br>
<br>
<b>set_cursor_pos</b> <i>line,column</i><br>
place the cursor at screen position line,column (counted in characters)<br>
0,0 is upper left corner, 24,39 the lower right corner<br>
arguments can be constants or registers<br>
<br>
<b>textcolor</b> <i>color</i><br>
sets the text color<br>
<br>
<b>toggle_carry</b><br>
Toggles the carry<br>
Registers modified: none<br>
<br>
<b>turn_off_cursor</b><br>
Turns off the blinking cursor and restores the character and color under cursor if necessary.<br>
Requires the KERNAL IRQ routines to be active<br>
If this function is used on the C128, a bank with visible ROM must be active.<br>
Use this before output of a char, otherwise you get inverse character artifacts when blink phase is on<br>
<br>
<b>turn_on_cursor</b><br>
Shows the blinking cursor during program execution<br>
Requires the KERNAL IRQ routines to be active<br>
if this function is used on the C128, a bank with visible ROM must be active.<br>
Turn off cursor briefly before output of a char, otherwise you get inverse character artifacts when blink phase is on<br>
<br>
<b>waitkey</b><br>
Waits until a key is pressed<br>
Function works independly of IRQ routine<br>
Registers modified: A<br>
<br>
<b>waitkeyreleased</b><br>
Waits until all keys are released<br>
Function works independly of IRQ routine<br>
Registers modified: A<br>
<br>
<b>readWASDspace</b><br>
Checks the keyboard for keypresses of W, A ,S, D and Space<br>
Output is a byte in A in the same format as a joystick value<br>
Since movement of joystick 1 disturbs the value, no keys are returen if joystick 1 is moved to any direction<br>
Function does not require the Kernal keyboard routine that is in the IRQ<br>
Registers modified: A,X<br>
<br>
<b>makesys</b> <i>[linenumber[,text[,</i> <i>address]]]</i><br>
Generates the code for a BASIC line with a SYS command, an optional text behind the sys command, and an optional specified entry address<br>
This is similar to the command line option  -u __EXEHDR__<br>
Difference is that with this function the code segment starts at $801, so .align is off only by 1<br>
If no SYS address is given, the target address is calculated to be the address right after the BASIC stub<br>
Default line number is 2020<br>
<br>
<b>memcopy</b> <i>src_addr,target_addr,length</i><br>
<br>
memcopy_from [AX|addr]<br>
memcopy_to   [AX|addr]<br>
memcopy [AX|length]<br>
Copies the memory area src_addr to src_addr+length over target_addr<br>
If the areas are overlapping, then target_addr must be < src_addr<br>
The three parameter version takes three constant numbers<br>
Alternatively, the function can be configured parameter by parameter, either with AX or a constant<br>
Registers modified: A,X,Y<br>
<br>
<b>memset</b> <i>start_addr,end_addr,fillvalue</i><br>
Fills the memory area between start_addr and end_adder with the byte fillvalue<br>
Registers modified: A,X,Y<br>
<br>
<b>save_prg</b> <i>filename,devicenr,startaddr,endaddr</i><br>
Saves the memory from startaddr to endaddr (including the endaddr) using the CBM ROM save function.<br>
The file will have a two-byte load address at its start<br>
if device number is 0, the last used device numner stored in address $BA is used. In case $BA contains 0, 8 is used as default<br>
Return value in carry, if carry is set, an error has happened and error code is returned in A, for example<br>
A = $05 (DEVICE NOT PRESENT)<br>
A = $00 (BREAK, RUN/STOP has been pressed during saving)<br>
Registers modified: A,X,Y<br>
<br>
<b>scramble</b> <i>startaddr,endaddr</i><br>
Scrambles/unscrambles a memory area. To unscramble, call scramble with the same parameters again<br>
<br>
<b>scratch_file</b> <i>filename[,devicenr]</i><br>
Deletes a file on disk. If device number is not stated or 0, the last used device number stored in address $BA is used. In case $BA contains 0, 8 is used as default.<br>
Registers modified: A,X,Y<br>
<br>
<b>set_raster_irq</b> <i>rasterline</i><br>
Changes the IRQ source to VIC raster interrupt<br>
Turns off the CIA IRQ source<br>
IRQ routine must acknowledge the IRQ source<br>
<br>
<b>to_screencode</b><br>
If the PETSCII value in A belongs to a printable character, it is converted to the corresponding screencode and returned in A<br>
Control codes will lead to an arbitrary byte.<br>
Registers modified: A<br>
<br>
<b>wait_for_rasterline</b> <i>rasterline[,reg]</i><br>
Macro inserting code doing busy waiting until the given rasterline is reached<br>
rasterline can be a value between 0 and 311 (for PAL systems) or 261 for NTSC systems, respectively<br>
The routine does not turn off the IRQ, so an IRQ might make it miss the rasterline it is waiting for.<br>
Registers modified: A or the register (A,X, or Y) given as second argument<br>
<br>
<b>screen_off</b><br>
turns off the screen via $d011<br>
The function always sets a 0 as high bit to avoid an unreachable raster irq line.<br>
<br>
<b>wait_screen_off</b><br>
Waits until raster>249 and turns screen off. Since it is necessary to write to $d011 to turn the screen off, we cannot avoid setting the high bit.<br>
The function always sets a 0 as high bit to avoid an unreachable raster irq line.<br>
<br>
<b>wait_screen_on</b><br>
turns the screen back on. Since it is necessary to write to $d011, the high bit of the next raster IRQ will be written (with a 0)<br>
<h2>Interacting with BASIC</h2>
<br>
<b>setBasicVarnam</b> <i>"varnam"</i><br>
This macro puts name and type of current variable into $45/46 (on C128 $47/48) in preparation for using ROM routines<br>
The values of $45 and $46 are also put into registers A and X<br>
The varname can be of 1 or 2 characters length plus an optional $ or % to indicate string or integer variables<br>
Example usage:<br>
setBasicVarnam "ab%" sets the integer variable ab%<br>
setBasicVarnam "s$" sets the string variable s$<br>
setBasicVarnam "x1" sets the floating point variable x1<br>
<br>
<b>getAddrOfBasicArryVar</b> <i>varnam,arrayidx</i><br>
The arrayidx must be not larger than decimal 10 for arrays to be created<br>
Example usage:<br>
getAddrOfBasicArryVar "ab%",3 returns the address of AB%(3)<br>
The return value is the variables address in AX<br>
uses zero page addresses $0b, $0c, $0d, $0e, $45, $46<br>
on C128 it uses zero page addresses $0d, $0e, $0f, $10, $47, $48<br>
On the C128, the bank will be set to 1 after return, so this code needs to be in common RAM or in bank 1.<br>
<h2>Special Macros for C128 in C128 Mode</h2>
<br>
<b>shadowIRQ</b> <i>off|on</i><br>
The C128 IRQ routine copies the values of the shadow registers $11D6-$11E6<br>
into VIC registers $D000-$D010 that control the positions of sprites on the<br>
screen. It further handles the BASIC commands SOUND, PLAY, and SPRITE. To<br>
avoid this, the macro  shadowIRQ off puts a 0 into memory address $0A04,<br>
telling the Kernal that BASIC has not been initialized yet.<br>
Cutting the IRQ routine provides a speed gain of about 2.5%<br>
Registers modified: A<br>
<br>
<b>set_VIC_RAMbank</b> <i>bank</i><br>
Tell the MMU to feed RAM bank 0 or 1 to the VIC<br>
This is a C128-only feature<br>
Bank must be 0 or 1<br>
I/O must be enabled for this macro to work<br>
</body>
</html>
